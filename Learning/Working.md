# Yolo项目-垒石石墨卷

## 前置内容
pycharm，anoconda，git  

### nvidia环境配置  

nvidia-smi (查看GPU)(linux)  
```
@echo off
:loop
cls
nvidia-smi
timeout /t 1 >nul
goto loop
```
^←windows，bat文件内容  

### 实施步骤  
1. 数据集分割  
2. git下载yolov12，安装torch以及依赖包  

## 你的训练日志位置：  
主要日志目录：**runs/detect/train12/**  
训练结果：**runs/detect/train12/results.csv** - 包含每个epoch的详细指标  
模型权重：**runs/detect/train12/weights/** - 包含 best.pt 和 last.pt  
训练参数：**runs/detect/train12/args.yaml** - 记录所有训练配置  
查看 **runs/detect/train12/weights/best.pt** 获取当前最佳模型。    
在**ultralytics/cfg**里找要训练的模型的对应的网络yaml。  



## 部署的前置要求  
1. pt转ort转trt(他们的关系，含义，转换方法)  
2. 安CUDA  **C:\Users\Administrator\AppData\Local\Temp\cuda**   
3. 安cudnn 
4. 使用训练脚本训练模型，拿官方的直接转ort，使用trtexec来ort转换trt  
5. 使用trtexec需要TensorRT，到官网安装  
6. 编onnxruntime库，用c++   
7. 需要知道模型部署时，模型的训练方式是seg还是det    
8. visual studio需要修改VC++目录和链接器中的输入    

##  试运行总结
1. 在visual studio里配置库的链接  

```
包含放包含，库放库（路径）

在链接器里放对应的lib
opencv_world460.lib
onnxruntime.lib
```

2. cuda和cudnn的版本要匹配，如果出现内存错误的问题，看控制台，大概率是版本没有匹配，少部分是资源声明（释放）顺序除了问题。  

3. 编写代码要用**PImpl**设计模式。  

## 打包DLL
1. 添加宏，添加include，添加lib，添加链接器中输入的附加依赖项。  

#ifdef YOLOV11SEG_EXPORTS  
#define YOLO_API __declspec(dllexport)  
#else  
#define YOLO_API __declspec(dllexport)  

在类前加class YOLO_API YOLOV11Seg{}  

生成即可。  

2. 在使用dll的时候，要添加链接器，包括  
常规：添加库目录（lib path）  
输入：附加依赖项（.lib）   
也就是说，lib是一个函数内容的索引，dll是一个包含函数内容的文件。  
lib可以放在别处，用添加库目录和依赖项的方式找到它，而dll最好是放在exe同路径下。    

# 训练曲线说明  

## 看两张图  
### F1-Confidence  
置信控制过杀，漏检。    
置信降低，过杀控制不住。  
置信升高，漏检控制不住。  

### Instance  
看缺陷的分布情况，数据平衡。   

# BOHR DFM设计文档  

## 划分模型秘籍  
主要看检测区域设计部分，在那里有主要的检测内容，包括以下内容：  
- 光源信息  
- 拍照点  
- 拍照图片数量  
- 产品移动数量  
- 拍照+存储耗时  
- Station condition的详细说明  

使用多个station的信息，来判断模型合并的可能性。  
一看光源，光源一样，那么成像就有一致的可能性。  
二看检测类型，缺陷类型一样，且光源一样，那么就有缺陷成像一致的可能性；如果光源不一样而缺陷类型一样，成像一致性不能保证，一定不能合并。    
三看图片尺寸（很有说法），图片尺寸接近有合并的可能性。   
**总的来说是看缺陷成像特征一致性**。  

使用DFM的标定最小NG尺寸来计算图片中的缺陷区域大小，使用每个图片的单像素精度计算缺陷像素块个数，使用缺陷像素块计算缩放后像素块个数，缩放后像素块不能低于9个。   

划分模型更像是一个工程定量的过程，是接下来的模型训练的总体方针，为待处理数据划定不同的处理方式，细化处理过程，落定到每个资源上。所以划分讲究合理性，资源承接性，任务量充实性，训练可行性。  

# 模型检出结果分析及措施秘籍  

## 一个好模型必须注意的三点  

1. 数据质量。  
2. 缺陷明确定义。  
3. 缺陷数量分布均衡。   

## 处理过杀漏检的部分情况及方法  

### 缺失部件情况  
可以使用特征连接来检测缺失区域，后使用分类模型来判定是否有缺失。    
两个模型串行运行。  
1. 标注部位 → 检测模型输出位置；  
2. 裁剪ROI → 分类模型判断缺料与否；  
3. 推理时串行运行两个模型，得到最终缺料检测结果。  

### 特征重叠误检情况  
将误检部位打上标注，进入模型训练，并不检测这一缺陷。  
显示负样本建模，backbone学到两者的特增差异，分类头head就能区分它们。  
让模型主动学会它长什么样。   

### 特征丢失时为缺陷情况  
将有特征时（即ok品）打上标注，未检测到即为出现缺陷。  
核心是把“存在的特征”作为正样本去检测/分割/定位，需要把模型调成“少漏报”为首要目标。  

| 检测逻辑        | 核心思路                | 典型应用        |
| ----------- | ------------------- | ----------- |
| **缺陷直接检测**  | 直接标注缺陷区域，用检测/分割模型识别 | 划痕、裂纹、缺料、异物 |
| **特征存在检测**  | 标注应存在的特征，缺失即缺陷      | 螺丝、焊点、孔位检测  |
| **负样本抑制检测** | 显式标注易误检区域为另一类，推理时忽略 | 金属反光、油污斑点误检 |
| **二阶段检测**   | 阶段1找候选 → 阶段2分类确认    | 缺料、轻微划伤     |
| **模板对比**    | 与标准模板做对齐/差分         | PCB线路、印刷缺陷  |
| **区域屏蔽**    | 检测前直接屏蔽无关区域         | 背景杂乱场景      |
| **轮廓/尺寸测量** | 基于边缘/拟合测尺寸          | 工件变形、尺寸偏差   |
| **光学对比检测**  | 用多光源拍摄，检测反射/吸收差异    | 刻字检测、反光涂层缺陷 |
| **规则阈值检测**  | 灰度、颜色、纹理特征阈值判断      | 简单表面污染      |  

## 最终要达到的    
**看到一个缺陷就要知道它的处理方式**。   

总结在一个漏检、过杀的数据集中，存在的主要缺陷有以下：  
1. 缺陷形态不一导致漏检，如本身形态多样的现状不良。  
2. 缺陷未准确定义，如压印的形态多变，点状可以是，现状也可以是。  
3. 诡异的叠放情况。  
4. 自身形态的缺失，不可控的随机的缺失。  
5. 特征消失是缺陷，这种过杀是对ok的漏检。   

直接说明：  
多的部分（废料残留）可以直接标。  
卷边折角也可以直接标。   

特征缺失型缺陷的核心是结构完整性，即对比结构是否完整。  
形态异常型缺陷是可以直接标注的，因为它们是正品中根本不存在的形态，只要出现就高度可疑。   

# 完成一个项目  
## 前期应该做的工作  
- 模型训练框架  
需要确定能够正确运行，做一个模版训练框架压缩包出来，用于各个硬件环境一键移植（因为会用到多个服务器）。  

- 数据增强工程  
需要确定数据能够正确增强，这个是工具工程，重点在正确使用，**data_conversion_utils**里的数据格式转换，标签数量统计，数据增强工具。  


## 总览表格的制作  
- 放一个智能表格在项目进度表中（自己做一个overview模版放在企业微信的智能表格里）      

- 主要是我这里算法出表格框架，使用模型的划分来确定表格结构，各项指标沿用历史指标。    
框架划分完成，交给光学及其他部门填充对应内容。  
所以，**划分模型是基本功**，需要多练。  

- 划分模型，没什么技巧，合理就行，图片数量，检测类型，不多不少得放到一个模型里检测就可以。  

## Airports图片查看    
**主要看轻微缺陷**。大部分都是缺少轻微缺陷的图，存在漏检风险。  
只有反面压伤缺陷特征明显，比较容易检测。  
顶面大小边可以用传统来检测。  

PVD前后的图片以及缺陷成像不一样，缺陷类型有差别，需要分别判断。  

若将缺陷标注为无成像，可能是图像中没有可用的有效图像信息。   

若是缺陷与表面相似，那就是有过杀风险。  

总结下来就是，以成像效果、混淆可能性和特征显式表达为标准来划定检测风险。  

这指导了模型划分、训练以及后期模型迭代方向。  

## 确定工控机
使用划分的模型以及工位信息，来确定工控机的承载，即哪些模型放到主机，哪些模型放到副机，来得到主副机的配置情况。  

目前的点是图片量均衡，所分配的机器模型量均衡。  


